[{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS1061",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS1061)"
		}
	},
	"severity": 8,
	"message": "'InventoryPaperDollUI.PaperDollSlot' does not contain a definition for 'GetItemInSlot' and no accessible extension method 'GetItemInSlot' accepting a first argument of type 'InventoryPaperDollUI.PaperDollSlot' could be found (are you missing a using directive or an assembly reference?)",
	"startLineNumber": 551,
	"startColumn": 42,
	"endLineNumber": 551,
	"endColumn": 55,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS1503",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS1503)"
		}
	},
	"severity": 8,
	"message": "Argument 1: cannot convert from 'InventoryPaperDollUI.PaperDollSlot' to 'UnityEngine.Component'",
	"startLineNumber": 554,
	"startColumn": 32,
	"endLineNumber": 554,
	"endColumn": 36,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS0103",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS0103)"
		}
	},
	"severity": 8,
	"message": "The name 'equipmentSlotUIs' does not exist in the current context",
	"startLineNumber": 561,
	"startColumn": 13,
	"endLineNumber": 561,
	"endColumn": 29,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS0103",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS0103)"
		}
	},
	"severity": 8,
	"message": "The name 'equipmentSlotUIs' does not exist in the current context",
	"startLineNumber": 561,
	"startColumn": 41,
	"endLineNumber": 561,
	"endColumn": 57,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS0103",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS0103)"
		}
	},
	"severity": 8,
	"message": "The name 'equipmentSlotUIs' does not exist in the current context",
	"startLineNumber": 563,
	"startColumn": 34,
	"endLineNumber": 563,
	"endColumn": 50,
	"origin": "extHost1"
}]



[{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS1061",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS1061)"
		}
	},
	"severity": 8,
	"message": "'InventoryPaperDollUI.PaperDollSlot' does not contain a definition for 'GetItemInSlot' and no accessible extension method 'GetItemInSlot' accepting a first argument of type 'InventoryPaperDollUI.PaperDollSlot' could be found (are you missing a using directive or an assembly reference?)",
	"startLineNumber": 551,
	"startColumn": 42,
	"endLineNumber": 551,
	"endColumn": 55,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS1503",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS1503)"
		}
	},
	"severity": 8,
	"message": "Argument 1: cannot convert from 'InventoryPaperDollUI.PaperDollSlot' to 'UnityEngine.Component'",
	"startLineNumber": 554,
	"startColumn": 32,
	"endLineNumber": 554,
	"endColumn": 36,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS0103",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS0103)"
		}
	},
	"severity": 8,
	"message": "The name 'equipmentSlotUIs' does not exist in the current context",
	"startLineNumber": 561,
	"startColumn": 13,
	"endLineNumber": 561,
	"endColumn": 29,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS0103",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS0103)"
		}
	},
	"severity": 8,
	"message": "The name 'equipmentSlotUIs' does not exist in the current context",
	"startLineNumber": 561,
	"startColumn": 41,
	"endLineNumber": 561,
	"endColumn": 57,
	"origin": "extHost1"
},{
	"resource": "/C:/Users/PC/Desktop/Lucio/DEV_GAMES/UNITY/2D/RPG DOS MARES/Assets/Scripts/Inventory/UI/InventoryPaperDollUI.cs",
	"owner": "DocumentCompilerSemantic",
	"code": {
		"value": "CS0103",
		"target": {
			"$mid": 1,
			"path": "/query/roslyn.query",
			"scheme": "https",
			"authority": "msdn.microsoft.com",
			"query": "appId=roslyn&k=k(CS0103)"
		}
	},
	"severity": 8,
	"message": "The name 'equipmentSlotUIs' does not exist in the current context",
	"startLineNumber": 563,
	"startColumn": 34,
	"endLineNumber": 563,
	"endColumn": 50,
	"origin": "extHost1"
}]



using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

/// <summary>
/// Sistema de Drag & Drop CORRIGIDO
/// âœ… Ghost visual funcional
/// âœ… Raycast configurado corretamente
/// âœ… Drop detection funcionando
/// âœ… ProteÃ§Ã£o contra travamento se Canvas for null
/// </summary>
public class DraggableItem : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    public enum DragSource
    {
        InventoryTable,
        PaperDollSlot,
        EquipmentSlot
    }
    
    [Header("Visual Feedback")]
    [SerializeField] private float dragAlpha = 0.8f;
    [SerializeField] private Vector2 ghostOffset = new Vector2(32f, -32f);
    
    // Drag state
    private RectTransform rectTransform;
    private Canvas canvas;
    private CanvasGroup canvasGroup;
    
    // Original state
    private Vector2 originalPosition;
    private Transform originalParent;
    private int originalSiblingIndex;
    
    // Item info
    private ItemData itemData;
    private DragSource source;
    private ItemData.EquipmentSlot sourceEquipmentSlot;
    
    // Drag result
    private bool wasDroppedSuccessfully = false;
    
    // ğŸ”¥ GHOST VISUAL
    private GameObject ghostObject;
    private Image ghostImage;
    private RectTransform ghostRect;
    
    private void Awake()
    {
        rectTransform = GetComponent<RectTransform>();
        
        // ğŸ”¥ BUSCA CANVAS - VERSÃƒO SIMPLIFICADA E RÃPIDA
        canvas = GetComponentInParent<Canvas>();
        
        canvasGroup = GetComponent<CanvasGroup>();
        if (canvasGroup == null)
        {
            canvasGroup = gameObject.AddComponent<CanvasGroup>();
        }
    }
    
    public void SetupDraggable(ItemData item, DragSource dragSource, ItemData.EquipmentSlot equipSlot = ItemData.EquipmentSlot.None)
    {
        itemData = item;
        source = dragSource;
        sourceEquipmentSlot = equipSlot;
    }
    
    public void OnBeginDrag(PointerEventData eventData)
    {
        if (itemData == null)
        {
            Debug.LogError("âŒ Tentativa de arrastar item NULL!");
            return;
        }
        
        // ğŸ”¥ BUSCA INTELIGENTE DO CANVAS
        if (canvas == null)
        {
            // Tenta pelo parent primeiro
            canvas = GetComponentInParent<Canvas>();
            
            // Se nÃ£o achou, busca na cena
            if (canvas == null)
            {
                GameObject inventoryPanel = GameObject.Find("InventoryPanel");
                if (inventoryPanel != null)
                {
                    canvas = inventoryPanel.GetComponentInParent<Canvas>();
                }
                
                // Ãšltimo recurso
                if (canvas == null)
                {
                    canvas = FindFirstObjectByType<Canvas>();
                }
            }
            
            if (canvas != null)
            {
                Debug.Log($"âœ… Canvas encontrado: {canvas.name}");
            }
        }
        
        if (canvas == null)
        {
            Debug.LogWarning("âš ï¸ Canvas nÃ£o encontrado - drag pode nÃ£o funcionar corretamente");
            // NÃƒO retorna - tenta continuar
        }
        
        Debug.Log($"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Debug.Log($"â•‘  ğŸ¯ BEGIN DRAG: {itemData.itemName}");
        Debug.Log($"â•‘  ğŸ“ Source: {source}");
        Debug.Log($"â•‘  ğŸ° Slot: {itemData.equipmentSlot}");
        Debug.Log($"â•‘  â„¹ï¸ Arraste para o Paper Doll â†’");
        Debug.Log($"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        // Salva estado original
        originalPosition = rectTransform.anchoredPosition;
        originalParent = transform.parent;
        originalSiblingIndex = transform.GetSiblingIndex();
        
        // ğŸ”¥ CRIAR GHOST VISUAL (com proteÃ§Ã£o)
        CreateGhostVisual();
        
        // Torna objeto original semi-transparente
        if (canvasGroup != null)
        {
            canvasGroup.alpha = 0.3f;
            canvasGroup.blocksRaycasts = false;
        }
        
        wasDroppedSuccessfully = false;
        
        // Notifica InventoryUI
        if (InventoryUI.Instance != null)
        {
            InventoryUI.Instance.OnItemDragBegin(itemData, source, sourceEquipmentSlot);
        }
    }
    
    public void OnDrag(PointerEventData eventData)
    {
        // ğŸ”¥ PROTEÃ‡ÃƒO: Se nÃ£o tem ghost ou canvas, nÃ£o faz nada
        if (ghostObject == null || canvas == null || ghostRect == null) 
        {
            return;
        }
        
        // Move ghost com cursor
        Vector2 localPoint;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            canvas.transform as RectTransform,
            eventData.position,
            canvas.worldCamera,
            out localPoint
        );
        
        ghostRect.anchoredPosition = localPoint + ghostOffset;
    }
    
    public void OnEndDrag(PointerEventData eventData)
    {
        Debug.Log($"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Debug.Log($"â•‘  ğŸ END DRAG: {itemData?.itemName ?? "NULL"}");
        Debug.Log($"â•‘  âœ… Success: {wasDroppedSuccessfully}");
        Debug.Log($"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        // ğŸ”¥ DESTRUIR GHOST COM PROTEÃ‡ÃƒO
        if (ghostObject != null)
        {
            try
            {
                Destroy(ghostObject);
                ghostObject = null;
                ghostImage = null;
                ghostRect = null;
                Debug.Log("ğŸ‘» Ghost destruÃ­do");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"âŒ Erro ao destruir ghost: {e.Message}");
            }
        }
        
        // Restaura visual original COM PROTEÃ‡ÃƒO
        if (canvasGroup != null)
        {
            try
            {
                canvasGroup.alpha = 1f;
                canvasGroup.blocksRaycasts = true;
                Debug.Log("ğŸ¨ CanvasGroup restaurado");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"âŒ Erro ao restaurar CanvasGroup: {e.Message}");
            }
        }
        
        if (wasDroppedSuccessfully)
        {
            Debug.Log("   âœ… Drop bem-sucedido - item equipado");
            
            // ğŸ”¥ğŸ”¥ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Esconder/desativar o item original
            // Depois que o item foi equipado via drag & drop,
            // ele nÃ£o deve mais aparecer na tabela
            
            try
            {
                // 1. Desativa este GameObject (item na tabela)
                if (gameObject != null && gameObject.activeSelf)
                {
                    // ğŸ”¥ IMPORTANTE: NÃ£o destruir imediatamente, apenas desativar
                    // A destruiÃ§Ã£o serÃ¡ feita pelo Refresh da tabela
                    gameObject.SetActive(false);
                    Debug.Log("ğŸ­ Item original desativado da tabela");
                }
                
                // 2. Atualiza UI
                StartCoroutine(SafeRefreshUIAfterDrag());
            }
            catch (System.Exception e)
            {
                Debug.LogError($"âŒ Erro ao processar drop bem-sucedido: {e.Message}");
            }
        }
        else
        {
            Debug.Log("   â†©ï¸ Drop falhou - voltando ao lugar");
            
            // Se drop falhou, volta Ã  posiÃ§Ã£o original
            if (originalParent != null)
            {
                try
                {
                    transform.SetParent(originalParent, false);
                    transform.SetSiblingIndex(Mathf.Min(originalSiblingIndex, originalParent.childCount - 1));
                    rectTransform.anchoredPosition = originalPosition;
                    Debug.Log("   âœ… PosiÃ§Ã£o original restaurada");
                }
                catch (System.Exception e)
                {
                    Debug.LogError($"âŒ Erro ao restaurar posiÃ§Ã£o: {e.Message}");
                }
            }
        }
        
        // Notifica InventoryUI
        if (InventoryUI.Instance != null)
        {
            try
            {
                InventoryUI.Instance.OnItemDragEnd(itemData, wasDroppedSuccessfully);
            }
            catch (System.Exception e)
            {
                Debug.LogError($"âŒ Erro ao notificar InventoryUI: {e.Message}");
            }
        }
        
        // Limpa estado
        wasDroppedSuccessfully = false;
    }

    private System.Collections.IEnumerator SafeRefreshUIAfterDrag()
    {
        Debug.Log("ğŸ”„ Atualizando UI apÃ³s drag bem-sucedido...");
        
        // Aguarda 1 frame para garantir que o equipamento foi processado
        yield return null;
        
        try
        {
            // ğŸ”¥ USAR FindFirstObjectByType em vez de acessar campos privados
            InventoryTableUI tableUI = FindFirstObjectByType<InventoryTableUI>();
            if (tableUI != null)
            {
                tableUI.ForceRefresh();
                Debug.Log("âœ… Tabela atualizada (item removido)");
            }
            
            InventoryPaperDollUI paperDollUI = FindFirstObjectByType<InventoryPaperDollUI>();
            if (paperDollUI != null)
            {
                paperDollUI.UpdateAllSlots();
                
                // ğŸ”¥ Usar reflexÃ£o para chamar mÃ©todo se existir
                if (itemData != null && paperDollUI.GetType().GetMethod("SelectSlotWithItem") != null)
                {
                    // Chama com delay usando Invoke
                    paperDollUI.Invoke("SelectSlotWithItem", 0.1f);
                    Debug.Log($"ğŸ¯ SeleÃ§Ã£o de slot agendada para {itemData.itemName}");
                }
            }
            
            // Atualiza botÃµes via InventoryUI
            if (InventoryUI.Instance != null)
            {
                // ğŸ”¥ Agora pode acessar porque o campo Ã© pÃºblico
                InventoryUI.Instance.OnItemSelected(itemData);
                
                // Usa o mÃ©todo pÃºblico
                if (InventoryUI.Instance.GetType().GetMethod("PublicUpdateButtonStates") != null)
                {
                    InventoryUI.Instance.Invoke("PublicUpdateButtonStates", 0);
                }
                
                Debug.Log("âœ… BotÃµes atualizados");
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"âŒ Erro durante atualizaÃ§Ã£o: {e.Message}");
        }
        
        Debug.Log("âœ… AtualizaÃ§Ã£o apÃ³s drag completa!");
    }

    
    // ğŸ”¥ NOVO MÃ‰TODO: AtualizaÃ§Ã£o segura da UI
    private System.Collections.IEnumerator SafeRefreshUI()
    {
        Debug.Log("ğŸ”„ Iniciando atualizaÃ§Ã£o segura da UI...");
        
        // Aguarda 2 frames para garantir que tudo foi processado
        yield return null;
        yield return null;
        
        try
        {
            // ğŸ”¥ BUSCAR UI COMPONENTS NA CENA (mÃ©todo mais confiÃ¡vel)
            InventoryPaperDollUI paperDollUI = FindFirstObjectByType<InventoryPaperDollUI>();
            if (paperDollUI != null)
            {
                paperDollUI.UpdateAllSlots();
                Debug.Log("âœ… PaperDoll atualizado");
            }
            
            InventoryTableUI tableUI = FindFirstObjectByType<InventoryTableUI>();
            if (tableUI != null)
            {
                tableUI.ForceRefresh();
                Debug.Log("âœ… Tabela atualizada");
            }
            
            // Atualiza InventoryUI
            if (InventoryUI.Instance != null)
            {
                InventoryUI.Instance.RefreshUI();
                Debug.Log("âœ… InventoryUI atualizado");
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"âŒ Erro durante atualizaÃ§Ã£o: {e.Message}");
        }
        
        Debug.Log("âœ… AtualizaÃ§Ã£o segura completa!");
    }
    
    /// <summary>
    /// ğŸ”¥ CRIA GHOST VISUAL - VERSÃƒO COM PROTEÃ‡ÃƒO CONTRA TRAVAMENTO
    /// </summary>
    private void CreateGhostVisual()
    {
        // ğŸ”¥ VERIFICAÃ‡ÃƒO CRÃTICA: Se nÃ£o tem Canvas, NÃƒO cria ghost
        if (canvas == null)
        {
            Debug.LogWarning($"âš ï¸ NÃ£o foi possÃ­vel criar ghost para {itemData?.itemName} - Canvas Ã© NULL");
            return;
        }
        
        if (itemData == null)
        {
            Debug.LogError("âŒ itemData null! NÃ£o pode criar ghost.");
            return;
        }
        
        try
        {
            // 1. Criar GameObject
            ghostObject = new GameObject("DragGhost", typeof(RectTransform));
            ghostRect = ghostObject.GetComponent<RectTransform>();
            
            // 2. Parent no Canvas
            ghostObject.transform.SetParent(canvas.transform, false);
            ghostObject.transform.SetAsLastSibling();
            
            // 3. Configurar RectTransform
            ghostRect.sizeDelta = new Vector2(64f, 64f);
            ghostRect.anchorMin = new Vector2(0.5f, 0.5f);
            ghostRect.anchorMax = new Vector2(0.5f, 0.5f);
            ghostRect.pivot = new Vector2(0.5f, 0.5f);
            
            // 4. Adicionar Image com Ã­cone
            ghostImage = ghostObject.AddComponent<Image>();
            ghostImage.sprite = itemData.icon;
            ghostImage.color = new Color(1f, 1f, 1f, dragAlpha);
            ghostImage.raycastTarget = false;
            
            // 5. Adicionar CanvasGroup
            CanvasGroup ghostGroup = ghostObject.AddComponent<CanvasGroup>();
            ghostGroup.alpha = 1f;
            ghostGroup.blocksRaycasts = false;
            ghostGroup.interactable = false;
            
            // 6. Adicionar borda
            GameObject border = new GameObject("Border", typeof(RectTransform));
            border.transform.SetParent(ghostObject.transform, false);
            
            RectTransform borderRect = border.GetComponent<RectTransform>();
            borderRect.anchorMin = Vector2.zero;
            borderRect.anchorMax = Vector2.one;
            borderRect.sizeDelta = Vector2.zero;
            
            Image borderImage = border.AddComponent<Image>();
            borderImage.color = new Color(1f, 1f, 1f, 0.3f);
            borderImage.raycastTarget = false;
            
            border.transform.SetAsFirstSibling();
            
            Debug.Log($"   ğŸ‘» Ghost criado para {itemData.itemName}");
        }
        catch (System.Exception e)
        {
            Debug.LogError($"âŒ Erro ao criar ghost: {e.Message}");
            
            // Limpa qualquer objeto parcialmente criado
            if (ghostObject != null)
            {
                Destroy(ghostObject);
                ghostObject = null;
                ghostImage = null;
                ghostRect = null;
            }
        }
    }
    
    /// <summary>
    /// Marca que o drop foi bem-sucedido (chamado por DropZone)
    /// </summary>
    public void MarkDropSuccess()
    {
        wasDroppedSuccessfully = true;
        Debug.Log($"   âœ… Drop marcado como sucesso para {itemData?.itemName}");
    }
    
    // Getters
    public ItemData GetItemData() => itemData;
    public DragSource GetSource() => source;
    public ItemData.EquipmentSlot GetSourceSlot() => sourceEquipmentSlot;
    
    // Debug: Visualizar ghost na Scene view
    private void OnDrawGizmos()
    {
        if (ghostRect != null && Application.isPlaying)
        {
            Gizmos.color = Color.yellow;
            Vector3 worldPos = ghostRect.position;
            Gizmos.DrawWireCube(worldPos, new Vector3(64f, 64f, 0f));
        }
    }
}





using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

/// <summary>
/// DropZone CORRIGIDA - DetecÃ§Ã£o de drop melhorada
/// âœ… OnPointerEnter detecta corretamente
/// âœ… OnDrop funciona com ghost
/// âœ… Visual feedback melhorado
/// </summary>
public class DropZone : MonoBehaviour, IDropHandler, IPointerEnterHandler, IPointerExitHandler
{
    public enum DropType
    {
        PaperDollSlot,
        InventoryTable,
        TrashBin
    }
    
    [Header("Drop Zone Configuration")]
    [SerializeField] private DropType dropType = DropType.PaperDollSlot;
    [SerializeField] private ItemData.EquipmentSlot acceptedEquipmentSlot = ItemData.EquipmentSlot.None;
    
    [Header("Visual Feedback")]
    [SerializeField] private Image backgroundImage;
    [SerializeField] private Color normalColor = new Color(0.2f, 0.2f, 0.2f, 0.5f);
    [SerializeField] private Color hoverValidColor = new Color(0.2f, 0.8f, 0.2f, 0.7f);
    [SerializeField] private Color hoverInvalidColor = new Color(0.8f, 0.2f, 0.2f, 0.7f);
    
    [Header("ğŸ†• Debug Visualization")]
    [SerializeField] private bool showDebugGizmos = true;
    
    private bool isDraggingOver = false;
    private DraggableItem currentDragItem = null;
    private Color originalColor;
    
    // ğŸ†• Raycast target reference
    private Graphic raycastTarget;
    
    private void Awake()
    {
        // ğŸ”¥ BUSCAR OU CRIAR IMAGE PARA RAYCAST
        if (backgroundImage == null)
            backgroundImage = GetComponent<Image>();
        
        // ğŸ”¥ SE NÃƒO TEM IMAGE, CRIAR UM INVISÃVEL
        if (backgroundImage == null)
        {
            Debug.LogWarning($"âš ï¸ {gameObject.name}: Criando Image invisÃ­vel para raycast...");
            backgroundImage = gameObject.AddComponent<Image>();
            backgroundImage.color = new Color(0, 0, 0, 0.01f); // Quase invisÃ­vel mas aceita raycast
        }
        
        if (backgroundImage != null)
        {
            originalColor = backgroundImage.color;
            raycastTarget = backgroundImage;
            
            // ğŸ”¥ GARANTIR RAYCAST TARGET
            raycastTarget.raycastTarget = true;
            Debug.Log($"âœ… {gameObject.name}: RaycastTarget ATIVO");
        }
        else
        {
            Debug.LogError($"âŒ {gameObject.name}: FALHA ao criar raycast target!");
        }
        
        Debug.Log($"ğŸ¯ DropZone configurado: {gameObject.name}");
        Debug.Log($"   Tipo: {dropType}");
        Debug.Log($"   Aceita slot: {acceptedEquipmentSlot}");
    }
    
    private void OnValidate()
    {
        // Auto-setup no editor
        if (backgroundImage == null)
            backgroundImage = GetComponent<Image>();
        
        if (backgroundImage != null)
            backgroundImage.raycastTarget = true;
    }
    
    public void OnPointerEnter(PointerEventData eventData)
    {
        // ğŸ”¥ VERIFICAÃ‡ÃƒO MELHORADA
        if (eventData.pointerDrag == null) return;
        
        currentDragItem = eventData.pointerDrag.GetComponent<DraggableItem>();
        if (currentDragItem == null) return;
        
        isDraggingOver = true;
        
        bool canAccept = CanAcceptItem(currentDragItem);
        
        Debug.Log($"ğŸ“ OnPointerEnter: {gameObject.name}");
        Debug.Log($"   Item: {currentDragItem.GetItemData()?.itemName}");
        Debug.Log($"   Pode aceitar: {canAccept}");
        
        // Visual feedback
        if (backgroundImage != null)
        {
            backgroundImage.color = canAccept ? hoverValidColor : hoverInvalidColor;
        }
    }
    
    public void OnPointerExit(PointerEventData eventData)
    {
        isDraggingOver = false;
        currentDragItem = null;
        
        if (backgroundImage != null)
        {
            backgroundImage.color = originalColor;
        }
    }
    
    public void OnDrop(PointerEventData eventData)
    {
        Debug.Log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Debug.Log($"â•‘  ğŸ“¦ DROP EVENT em: {gameObject.name}");
        Debug.Log($"â•‘  ğŸ¯ Tipo: {dropType}");
        
        // ğŸ”¥ VERIFICAÃ‡ÃƒO ROBUSTA
        if (eventData.pointerDrag == null)
        {
            Debug.LogError("â•‘  âŒ eventData.pointerDrag is NULL!");
            Debug.Log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            return;
        }
        
        var draggableItem = eventData.pointerDrag.GetComponent<DraggableItem>();
        if (draggableItem == null)
        {
            Debug.LogError("â•‘  âŒ Sem componente DraggableItem!");
            Debug.Log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            return;
        }
        
        ItemData item = draggableItem.GetItemData();
        if (item == null)
        {
            Debug.LogError("â•‘  âŒ Item data is NULL!");
            Debug.Log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            return;
        }
        
        Debug.Log($"â•‘  ğŸ“¦ Item: {item.itemName}");
        Debug.Log($"â•‘  ğŸ“ Source: {draggableItem.GetSource()}");
        
        // Verificar se pode aceitar
        if (!CanAcceptItem(draggableItem))
        {
            Debug.LogWarning("â•‘  âš ï¸ Este drop zone NÃƒO aceita este item!");
            Debug.Log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            
            if (backgroundImage != null)
                backgroundImage.color = originalColor;
            
            return;
        }
        
        // ğŸ”¥ EXECUTAR AÃ‡ÃƒO
        bool success = false;
        
        switch (dropType)
        {
            case DropType.PaperDollSlot:
                success = HandleEquipDrop(draggableItem);
                break;
                
            case DropType.InventoryTable:
                success = HandleUnequipDrop(draggableItem);
                break;
                
            case DropType.TrashBin:
                success = HandleTrashDrop(draggableItem);
                break;
        }
        
        if (success)
        {
            Debug.Log("â•‘  âœ… Drop SUCESSO!");
            draggableItem.MarkDropSuccess();
        }
        else
        {
            Debug.LogError("â•‘  âŒ Drop FALHOU!");
        }
        
        if (backgroundImage != null)
            backgroundImage.color = originalColor;
        
        isDraggingOver = false;
        currentDragItem = null;
        
        Debug.Log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }
    
    private bool CanAcceptItem(DraggableItem draggableItem)
    {
        if (draggableItem == null) return false;
        
        ItemData item = draggableItem.GetItemData();
        if (item == null) return false;
        
        DraggableItem.DragSource source = draggableItem.GetSource();
        
        switch (dropType)
        {
            case DropType.PaperDollSlot:
                // SÃ³ aceita itens da tabela de inventÃ¡rio
                if (source != DraggableItem.DragSource.InventoryTable)
                    return false;
                
                // Deve ser equipamento
                if (!item.IsEquipment())
                    return false;
                
                // Verifica compatibilidade de slot
                return IsCompatibleEquipmentSlot(item.equipmentSlot, acceptedEquipmentSlot);
                
            case DropType.InventoryTable:
                // Aceita unequip do paper doll
                return source == DraggableItem.DragSource.PaperDollSlot;
                
            case DropType.TrashBin:
                // Aceita itens droppable
                return item.isDroppable;
                
            default:
                return false;
        }
    }
    
    private bool HandleEquipDrop(DraggableItem draggableItem)
    {
        try
        {
            ItemData item = draggableItem.GetItemData();
            
            Debug.Log($"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            Debug.Log($"â•‘  ğŸ¯ DROP ZONE: Tentando equipar");
            Debug.Log($"â•‘  ğŸ“¦ Item: {item?.itemName ?? "NULL"}");
            Debug.Log($"â•‘  ğŸ“ No slot: {acceptedEquipmentSlot}");
            Debug.Log($"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            
            if (item == null)
            {
                Debug.LogError("âŒ Item data is NULL!");
                return false;
            }
            
            if (InventoryManager.Instance == null)
            {
                Debug.LogError("âŒ InventoryManager nÃ£o encontrado!");
                return false;
            }
            
            // Verifica se item estÃ¡ no inventÃ¡rio
            int itemCount = InventoryManager.Instance.GetItemCount(item);
            Debug.Log($"ğŸ” Item no inventÃ¡rio: {itemCount}x");
            
            if (itemCount <= 0)
            {
                Debug.LogError($"âŒ {item.itemName} nÃ£o estÃ¡ no inventÃ¡rio!");
                return false;
            }
            
            // Verifica compatibilidade de slot
            if (!IsCompatibleEquipmentSlot(item.equipmentSlot, acceptedEquipmentSlot))
            {
                Debug.LogError($"âŒ Slot incompatÃ­vel: {item.equipmentSlot} â†’ {acceptedEquipmentSlot}");
                return false;
            }
            
            // ğŸ”¥ USAR InventoryManager diretamente
            Debug.Log("ğŸ¯ Usando InventoryManager para equipar...");
            bool success = InventoryManager.Instance.EquipItem(item);
            
            if (success)
            {
                Debug.Log($"âœ… {item.itemName} equipado com sucesso no slot {acceptedEquipmentSlot}!");
                
                // ğŸ”¥ğŸ”¥ğŸ”¥ CORREÃ‡ÃƒO: Esconder o item original da tabela
                if (draggableItem != null)
                {
                    GameObject draggableGameObject = draggableItem.gameObject;
                    if (draggableGameObject != null && draggableGameObject.activeSelf)
                    {
                        draggableGameObject.SetActive(false);
                        Debug.Log("ğŸ­ Item original da tabela desativado");
                    }
                }
                
                // ğŸ”¥ğŸ”¥ğŸ”¥ CORREÃ‡ÃƒO: Buscar componentes dinamicamente
                StartCoroutine(DelayedUIRefresh(item, draggableItem));
                
                return true;
            }
            else
            {
                Debug.LogError($"âŒ Falha ao equipar {item.itemName}!");
                
                // Se falhou, reativa o item original
                if (draggableItem != null && draggableItem.gameObject != null)
                {
                    draggableItem.gameObject.SetActive(true);
                    Debug.Log("ğŸ”„ Item original reativado (equip falhou)");
                }
                
                return false;
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"âŒ EXCEÃ‡ÃƒO em HandleEquipDrop: {e.Message}");
            Debug.LogError($"Stack Trace: {e.StackTrace}");
            
            return false;
        }
    }

    // ğŸ”¥ MÃ‰TODO AUXILIAR SIMPLIFICADO
    private System.Collections.IEnumerator DelayedUIRefresh(ItemData item, DraggableItem draggableItem)
    {
        // Aguarda 2 frames
        yield return null;
        yield return null;
        
        try
        {
            // 1. Atualizar tabela
            InventoryTableUI tableUI = FindFirstObjectByType<InventoryTableUI>();
            if (tableUI != null)
            {
                tableUI.ForceRefresh();
                Debug.Log("âœ… Tabela atualizada");
            }
            
            // 2. Atualizar paper doll
            InventoryPaperDollUI paperDollUI = FindFirstObjectByType<InventoryPaperDollUI>();
            if (paperDollUI != null)
            {
                paperDollUI.UpdateAllSlots();
                Debug.Log("âœ… PaperDoll atualizado");
            }
            
            // 3. Atualizar InventoryUI se disponÃ­vel
            if (InventoryUI.Instance != null)
            {
                InventoryUI.Instance.OnItemSelected(item);
                Debug.Log($"ğŸ¯ {item.itemName} selecionado");
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"âŒ Erro ao atualizar UI: {e.Message}");
        }
    }
    
    private bool HandleUnequipDrop(DraggableItem draggableItem)
    {
        ItemData item = draggableItem.GetItemData();
        ItemData.EquipmentSlot sourceSlot = draggableItem.GetSourceSlot();
        
        Debug.Log($"   ğŸ”§ Tentando DESEQUIPAR: {item.itemName}");
        Debug.Log($"   ğŸ“ Do slot: {sourceSlot}");
        
        if (InventoryManager.Instance == null)
        {
            Debug.LogError("   âŒ InventoryManager nÃ£o encontrado!");
            return false;
        }
        
        ItemData unequipped = InventoryManager.Instance.UnequipItem(sourceSlot);
        
        if (unequipped != null)
        {
            Debug.Log($"   âœ… {unequipped.itemName} desequipado com sucesso!");
            return true;
        }
        else
        {
            Debug.LogError($"   âŒ Falha ao desequipar do slot {sourceSlot}");
            return false;
        }
    }
    
    private bool HandleTrashDrop(DraggableItem draggableItem)
    {
        ItemData item = draggableItem.GetItemData();
        
        Debug.Log($"   ğŸ—‘ï¸ Deletando: {item.itemName}");
        
        if (InventoryManager.Instance != null)
        {
            bool removed = InventoryManager.Instance.RemoveItem(item, 1);
            
            if (removed)
            {
                Debug.Log($"   âœ… {item.itemName} deletado!");
                return true;
            }
        }
        
        return false;
    }
    
    private bool IsCompatibleEquipmentSlot(ItemData.EquipmentSlot itemSlot, ItemData.EquipmentSlot targetSlot)
    {
        if (itemSlot == targetSlot) return true;
        
        // Mapeamento de compatibilidade
        switch (targetSlot)
        {
            case ItemData.EquipmentSlot.MainHand:
                return itemSlot == ItemData.EquipmentSlot.Weapon;
                
            case ItemData.EquipmentSlot.Weapon:
                return itemSlot == ItemData.EquipmentSlot.MainHand;
                
            default:
                return false;
        }
    }
    
    // Getters
    public DropType GetDropType() => dropType;
    public ItemData.EquipmentSlot GetAcceptedEquipmentSlot() => acceptedEquipmentSlot;
    
    public void SetAcceptedSlot(ItemData.EquipmentSlot slot)
    {
        acceptedEquipmentSlot = slot;
    }
    
    // ğŸ†• DEBUG: Visualizar drop zone na Scene view
    private void OnDrawGizmos()
    {
        if (!showDebugGizmos) return;
        
        RectTransform rect = GetComponent<RectTransform>();
        if (rect == null) return;
        
        // Cor baseada no tipo
        Color gizmoColor = Color.white;
        switch (dropType)
        {
            case DropType.PaperDollSlot:
                gizmoColor = Color.cyan;
                break;
            case DropType.InventoryTable:
                gizmoColor = Color.green;
                break;
            case DropType.TrashBin:
                gizmoColor = Color.red;
                break;
        }
        
        if (isDraggingOver)
            gizmoColor = Color.yellow;
        
        Gizmos.color = gizmoColor;
        
        Vector3 worldPos = rect.position;
        Vector3 size = new Vector3(rect.rect.width, rect.rect.height, 0f);
        
        Gizmos.DrawWireCube(worldPos, size);
    }
}



using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using Combat.TurnBased;

public class InventoryManager : MonoBehaviour
{
    // ============================================
    // SINGLETON SIMPLIFICADO
    // ============================================
    private static InventoryManager _instance;
    public static InventoryManager Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = FindFirstObjectByType<InventoryManager>();
            }
            return _instance;
        }
    }
    
    // ============================================
    // CLASSES DE DADOS
    // ============================================
    
    [System.Serializable]
    public class InventorySlot
    {
        public ItemData item;
        public int quantity;
        public int slotIndex;
        public bool isEquipped;
        
        public InventorySlot(ItemData item, int quantity, int slotIndex)
        {
            this.item = item;
            this.quantity = quantity;
            this.slotIndex = slotIndex;
            this.isEquipped = false;
        }
        
        public bool IsEmpty => item == null || quantity <= 0;
        public bool IsStackFull => item != null && quantity >= item.stackLimit;
        
        public bool CanAddToStack(int amount = 1)
        {
            if (item == null) return true;
            return quantity + amount <= item.stackLimit;
        }
    }
    
    [System.Serializable]
    public class EquipmentLoadout
    {
        public ItemData weapon;
        public ItemData armor;
        public ItemData helmet;
        public ItemData gloves;
        public ItemData boots;
        public ItemData accessory;
        public ItemData ring;
        public ItemData amulet;
        public ItemData body;
        public ItemData offHand;
        public ItemData longRange;
        public ItemData mainHand;
        
        public ItemData GetItemInSlot(ItemData.EquipmentSlot slot)
        {
            switch (slot)
            {
                case ItemData.EquipmentSlot.Weapon: return weapon;
                case ItemData.EquipmentSlot.Armor: return armor;
                case ItemData.EquipmentSlot.Body: return body;
                case ItemData.EquipmentSlot.Helmet: return helmet;
                case ItemData.EquipmentSlot.Gloves: return gloves;
                case ItemData.EquipmentSlot.Boots: return boots;
                case ItemData.EquipmentSlot.Accessory: return accessory;
                case ItemData.EquipmentSlot.Ring: return ring;
                case ItemData.EquipmentSlot.Amulet: return amulet;
                case ItemData.EquipmentSlot.OffHand: return offHand;
                case ItemData.EquipmentSlot.LongRange: return longRange;
                case ItemData.EquipmentSlot.MainHand: return mainHand;
                default: return null;
            }
        }
        
        public void EquipItem(ItemData item)
        {
            if (item == null || !item.IsEquipment()) return;
            
            switch (item.equipmentSlot)
            {
                case ItemData.EquipmentSlot.Weapon: weapon = item; break;
                case ItemData.EquipmentSlot.Armor: armor = item; break;
                case ItemData.EquipmentSlot.Body: body = item; break;
                case ItemData.EquipmentSlot.Helmet: helmet = item; break;
                case ItemData.EquipmentSlot.Gloves: gloves = item; break;
                case ItemData.EquipmentSlot.Boots: boots = item; break;
                case ItemData.EquipmentSlot.Accessory: accessory = item; break;
                case ItemData.EquipmentSlot.Ring: ring = item; break;
                case ItemData.EquipmentSlot.Amulet: amulet = item; break;
                case ItemData.EquipmentSlot.OffHand: offHand = item; break;
                case ItemData.EquipmentSlot.LongRange: longRange = item; break;
                case ItemData.EquipmentSlot.MainHand: mainHand = item; break;
            }
        }
        
        public ItemData UnequipItem(ItemData.EquipmentSlot slot)
        {
            ItemData unequipped = GetItemInSlot(slot);
            
            switch (slot)
            {
                case ItemData.EquipmentSlot.Weapon: weapon = null; break;
                case ItemData.EquipmentSlot.Armor: armor = null; break;
                case ItemData.EquipmentSlot.Body: body = null; break;
                case ItemData.EquipmentSlot.Helmet: helmet = null; break;
                case ItemData.EquipmentSlot.Gloves: gloves = null; break;
                case ItemData.EquipmentSlot.Boots: boots = null; break;
                case ItemData.EquipmentSlot.Accessory: accessory = null; break;
                case ItemData.EquipmentSlot.Ring: ring = null; break;
                case ItemData.EquipmentSlot.Amulet: amulet = null; break;
                case ItemData.EquipmentSlot.OffHand: offHand = null; break;
                case ItemData.EquipmentSlot.LongRange: longRange = null; break;
                case ItemData.EquipmentSlot.MainHand: mainHand = null; break;
            }
            
            return unequipped;
        }
        
        public int GetTotalStatBonus(ItemData.StatType statType)
        {
            int total = 0;
            
            ItemData[] equippedItems = new ItemData[] 
            { 
                weapon, armor, body, helmet, gloves, boots, accessory, ring, amulet,
                offHand, longRange, mainHand
            };
            
            foreach (var item in equippedItems)
            {
                if (item == null) continue;
                
                switch (statType)
                {
                    case ItemData.StatType.Attack: 
                        total += item.attackBonus; break;
                    case ItemData.StatType.Defense: 
                        total += item.defenseBonus; break;
                    case ItemData.StatType.MagicAttack: 
                        total += item.magicAttackBonus; break;
                    case ItemData.StatType.MagicDefense: 
                        total += item.magicDefenseBonus; break;
                    case ItemData.StatType.Speed: 
                        total += item.speedBonus; break;
                }
            }
            
            return total;
        }
    }
    
    // ============================================
    // CONFIGURAÃ‡ÃƒO
    // ============================================
    
    [Header("Inventory Settings")]
    [SerializeField] private int inventorySize = 30;
    [SerializeField] private int maxCurrency = 999999;
    
    [Header("Starting Items (Debug)")]
    [SerializeField] private ItemData[] startingItems;
    [SerializeField] private int startingCurrency = 100;
    
    [Header("Debug")]
    [SerializeField] private bool showDebugLogs = false;
    
    [Header("Weight System")]
    [SerializeField] private float maxWeight = 100f;
    
    // ============================================
    // DADOS DO INVENTÃRIO
    // ============================================
    
    private List<InventorySlot> inventorySlots = new List<InventorySlot>();
    private EquipmentLoadout currentEquipment = new EquipmentLoadout();
    private int currentCurrency = 0;
    private float currentWeight = 0f;
    
    // ============================================
    // EVENTOS
    // ============================================
    
    public System.Action OnInventoryChanged;
    public System.Action OnCurrencyChanged;
    public System.Action OnEquipmentChanged;
    public System.Action<float, float> OnWeightChanged;
    
    // ============================================
    // INICIALIZAÃ‡ÃƒO
    // ============================================
    
    private void Awake()
    {
        if (_instance != null && _instance != this)
        {
            Destroy(gameObject);
            return;
        }
        
        _instance = this;
        DontDestroyOnLoad(gameObject);
        
        InitializeInventory();
    }
    
    private void Start()
    {
        InitializeInventory();
        
        // Try to load from GameDataManager
        if (GameDataManager.Instance != null)
        {
            LoadFromGameData();
        }
        
        // Add starting items only if inventory is empty
        bool hasItems = inventorySlots.Any(slot => !slot.IsEmpty);
        
        if (!hasItems && startingItems.Length > 0)
        {
            foreach (var item in startingItems)
            {
                if (item != null)
                {
                    AddItem(item, item.stackLimit > 1 ? 3 : 1);
                }
            }
            AddCurrency(startingCurrency);
        }
    }
    
    private void InitializeInventory()
    {
        inventorySlots.Clear();
        
        for (int i = 0; i < inventorySize; i++)
        {
            inventorySlots.Add(new InventorySlot(null, 0, i));
        }
        
        currentWeight = 0f;
    }
    
    private void CalculateCurrentWeight()
    {
        float totalWeight = 0f;
        
        foreach (var slot in inventorySlots)
        {
            if (!slot.IsEmpty && slot.item != null)
            {
                totalWeight += slot.item.weight * slot.quantity;
            }
        }
        
        currentWeight = totalWeight;
    }
    
    // ============================================
    // INTEGRAÃ‡ÃƒO COM GAMEDATAMANAGER
    // ============================================
    
    private void LoadFromGameData()
    {
        var inventoryData = GameDataManager.Instance.GetInventoryData();
        if (inventoryData == null) return;
        
        InitializeInventory();
        currentCurrency = inventoryData.currency;
        
        OnInventoryChanged?.Invoke();
        OnCurrencyChanged?.Invoke();
    }
    
    public void SaveToGameData()
    {
        if (GameDataManager.Instance == null) return;
        
        var gameData = GameDataManager.Instance.GetCurrentGameData();
        if (gameData == null) return;
        
        var inventoryData = GameDataManager.Instance.GetInventoryData();
        if (inventoryData == null) return;
        
        inventoryData.currency = currentCurrency;
        
        OnInventoryChanged?.Invoke();
        
        if (gameData.saveSlot > 0)
        {
            GameDataManager.Instance.SaveGame(gameData.saveSlot);
        }
    }

    // ============================================
    // GERENCIAMENTO DE ITENS
    // ============================================
    
    public bool AddItem(ItemData item, int quantity = 1)
    {
        if (item == null || quantity <= 0) return false;
        
        float addedWeight = item.weight * quantity;
        if (currentWeight + addedWeight > maxWeight)
        {
            if (showDebugLogs)
                Debug.LogWarning($"[InventoryManager] Weight limit exceeded!");
            return false;
        }
        
        // Try to add to existing stacks
        if (item.stackLimit > 1)
        {
            foreach (var slot in inventorySlots)
            {
                if (!slot.IsEmpty && slot.item == item && !slot.IsStackFull)
                {
                    int canAdd = item.stackLimit - slot.quantity;
                    int addAmount = Mathf.Min(quantity, canAdd);
                    
                    slot.quantity += addAmount;
                    quantity -= addAmount;
                    
                    if (quantity <= 0)
                    {
                        CalculateCurrentWeight();
                        OnInventoryChanged?.Invoke();
                        return true;
                    }
                }
            }
        }
        
        // Fill empty slots
        foreach (var slot in inventorySlots)
        {
            if (slot.IsEmpty)
            {
                slot.item = item;
                slot.quantity = Mathf.Min(quantity, item.stackLimit);
                quantity -= slot.quantity;
                
                if (quantity <= 0)
                {
                    CalculateCurrentWeight();
                    OnInventoryChanged?.Invoke();
                    return true;
                }
            }
        }
        
        if (quantity > 0)
        {
            if (showDebugLogs)
                Debug.LogWarning($"[InventoryManager] Not enough space!");
            return false;
        }
        
        return true;
    }
    
    public bool RemoveItem(ItemData item, int quantity = 1)
    {
        if (item == null || quantity <= 0) return false;
        
        int remaining = quantity;
        
        for (int i = inventorySlots.Count - 1; i >= 0; i--)
        {
            var slot = inventorySlots[i];
            
            if (!slot.IsEmpty && slot.item == item)
            {
                int removeAmount = Mathf.Min(slot.quantity, remaining);
                slot.quantity -= removeAmount;
                remaining -= removeAmount;
                
                if (slot.quantity <= 0)
                {
                    slot.item = null;
                    slot.quantity = 0;
                }
                
                if (remaining <= 0)
                {
                    CalculateCurrentWeight();
                    OnInventoryChanged?.Invoke();
                    return true;
                }
            }
        }
        
        return remaining <= 0;
    }
    
    public bool HasItem(ItemData item, int quantity = 1)
    {
        if (item == null) return false;
        
        int total = 0;
        foreach (var slot in inventorySlots)
        {
            if (!slot.IsEmpty && slot.item == item)
            {
                total += slot.quantity;
                if (total >= quantity) return true;
            }
        }
        
        return total >= quantity;
    }
    
    public int GetItemCount(ItemData item)
    {
        if (item == null) return 0;
        
        int total = 0;
        foreach (var slot in inventorySlots)
        {
            if (!slot.IsEmpty && slot.item == item)
            {
                total += slot.quantity;
            }
        }
        
        return total;
    }
    
    public List<InventorySlot> GetSlotsWithItem(ItemData item)
    {
        List<InventorySlot> slots = new List<InventorySlot>();
        
        foreach (var slot in inventorySlots)
        {
            if (!slot.IsEmpty && slot.item == item)
            {
                slots.Add(slot);
            }
        }
        
        return slots;
    }
    
    // ============================================
    // GERENCIAMENTO DE EQUIPAMENTO
    // ============================================
    
    public bool EquipItem(ItemData item)
    {
        if (item == null || !item.IsEquipment()) 
        {
            Debug.LogError($"âŒ EquipItem: Item null ou nÃ£o Ã© equipamento");
            return false;
        }
        
        Debug.Log($"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Debug.Log($"â•‘  ğŸ”¥ EQUIP ITEM INICIADO");
        Debug.Log($"â•‘  ğŸ“¦ Item: {item.itemName}");
        Debug.Log($"â•‘  ğŸ° Slot: {item.equipmentSlot}");
        Debug.Log($"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        // 1. Verifica se tem o item no inventÃ¡rio
        if (!HasItem(item, 1))
        {
            Debug.LogError($"âŒ Item nÃ£o estÃ¡ no inventÃ¡rio: {item.itemName}");
            return false;
        }
        
        // 2. Pega o personagem ativo
        if (PartyManager.Instance == null)
        {
            Debug.LogError("âŒ PartyManager nÃ£o encontrado!");
            return false;
        }
        
        var activeCharacter = PartyManager.Instance.GetActiveMember();
        if (activeCharacter == null)
        {
            Debug.LogError("âŒ Personagem ativo nÃ£o encontrado!");
            return false;
        }
        
        Debug.Log($"ğŸ¯ Personagem ativo: {activeCharacter.characterName}");
        
        // 3. Verifica se pode equipar
        if (!activeCharacter.CanEquipItem(item))
        {
            Debug.LogError($"âŒ {activeCharacter.characterName} nÃ£o pode equipar {item.itemName}");
            return false;
        }
        
        // 4. Pega o item atualmente equipado no slot
        ItemData currentlyEquipped = currentEquipment.GetItemInSlot(item.equipmentSlot);
        Debug.Log($"ğŸ” Item atualmente equipado: {currentlyEquipped?.itemName ?? "None"}");
        
        // 5. Se jÃ¡ estÃ¡ equipado, retorna sucesso (nÃ£o faz nada)
        if (currentlyEquipped == item)
        {
            Debug.Log($"âš ï¸ {item.itemName} jÃ¡ estÃ¡ equipado!");
            return true;
        }
        
        // 6. Remove do inventÃ¡rio
        Debug.Log($"ğŸ“¦ Removendo {item.itemName} do inventÃ¡rio...");
        if (!RemoveItem(item, 1))
        {
            Debug.LogError($"âŒ Falha ao remover {item.itemName} do inventÃ¡rio!");
            return false;
        }
        
        // 7. Se tinha item equipado, adiciona ao inventÃ¡rio
        if (currentlyEquipped != null)
        {
            Debug.Log($"ğŸ”„ Desequipando {currentlyEquipped.itemName}...");
            
            // Desequipa do InventoryManager
            currentEquipment.UnequipItem(item.equipmentSlot);
            
            // Adiciona ao inventÃ¡rio
            if (!AddItem(currentlyEquipped, 1))
            {
                Debug.LogError($"âŒ NÃ£o foi possÃ­vel adicionar {currentlyEquipped.itemName} ao inventÃ¡rio!");
                // Tenta recolocar o item original
                AddItem(item, 1);
                return false;
            }
        }
        
        // 8. Equipa o novo item no InventoryManager
        Debug.Log($"ğŸ¯ Equipando {item.itemName} no InventoryManager...");
        currentEquipment.EquipItem(item);
        
        // 9. ğŸ”¥ğŸ”¥ğŸ”¥ SINCRONIZAÃ‡ÃƒO COM O PERSONAGEM
        Debug.Log($"ğŸ”„ Sincronizando com {activeCharacter.characterName}...");
        SyncEquipmentWithActiveCharacter();
        
        // 10. VerificaÃ§Ã£o
        var verifyEquipped = currentEquipment.GetItemInSlot(item.equipmentSlot);
        if (verifyEquipped != item)
        {
            Debug.LogError($"âŒ VERIFICAÃ‡ÃƒO FALHOU: Item nÃ£o foi equipado!");
            // Revert
            currentEquipment.UnequipItem(item.equipmentSlot);
            AddItem(item, 1);
            if (currentlyEquipped != null) currentEquipment.EquipItem(currentlyEquipped);
            return false;
        }
        
        // 11. Atualiza UI
        Debug.Log($"âœ… {item.itemName} equipado com sucesso!");
        
        OnEquipmentChanged?.Invoke();
        OnInventoryChanged?.Invoke();
        
        // 12. Salva
        SaveToGameData();
        
        Debug.Log($"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Debug.Log($"â•‘  âœ… EQUIP ITEM FINALIZADO COM SUCESSO");
        Debug.Log($"â•‘  ğŸ“¦ Item: {item.itemName}");
        Debug.Log($"â•‘  ğŸ‘¤ Personagem: {activeCharacter.characterName}");
        Debug.Log($"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        return true;
    }

    public ItemData UnequipItem(ItemData.EquipmentSlot slot)
    {
        ItemData unequipped = currentEquipment.UnequipItem(slot);
        
        if (unequipped != null)
        {
            if (!CanCarryWeight(unequipped.weight))
            {
                currentEquipment.EquipItem(unequipped);
                return null;
            }
            
            bool added = AddItem(unequipped, 1);
            
            if (!added)
            {
                currentEquipment.EquipItem(unequipped);
                return null;
            }
            
            // ğŸ”¥ğŸ”¥ğŸ”¥ NOVO: SINCRONIZA COM O CHARACTER ATIVO
            SyncEquipmentWithActiveCharacter();
            
            OnEquipmentChanged?.Invoke();
            OnInventoryChanged?.Invoke();
            SaveToGameData();
        }
        
        return unequipped;
    }

    // ğŸ”¥ğŸ”¥ğŸ”¥ NOVO MÃ‰TODO: Sincroniza equipamento com o character ativo
    private void SyncEquipmentWithActiveCharacter()
    {
        if (PartyManager.Instance == null) return;
        
        var activeCharacter = PartyManager.Instance.GetActiveMember();
        if (activeCharacter == null) return;
        
        // Garante que o character tem um EquipmentLoadout
        if (activeCharacter.currentEquipment == null)
        {
            activeCharacter.currentEquipment = new EquipmentLoadout();
        }
        
        // ğŸ”¥ COPIA TODOS OS EQUIPAMENTOS DO INVENTORYMANAGER PARA O CHARACTER
        var slotTypes = System.Enum.GetValues(typeof(ItemData.EquipmentSlot));
        
        foreach (ItemData.EquipmentSlot slot in slotTypes)
        {
            if (slot == ItemData.EquipmentSlot.None) continue;
            
            // Pega do InventoryManager
            var equippedItem = currentEquipment.GetItemInSlot(slot);
            
            // Limpa o slot do character
            activeCharacter.currentEquipment.UnequipItem(slot);
            
            // Se tem item, equipa
            if (equippedItem != null)
            {
                activeCharacter.currentEquipment.EquipItem(equippedItem);
            }
        }
        
        Debug.Log($"ğŸ”„ Equipamento sincronizado com {activeCharacter.characterName}");
    }
    
    public ItemData GetEquippedItem(ItemData.EquipmentSlot slot)
    {
        return currentEquipment.GetItemInSlot(slot);
    }
    
    public int GetEquipmentStatBonus(ItemData.StatType statType)
    {
        return currentEquipment.GetTotalStatBonus(statType);
    }
    
    // ============================================
    // SISTEMA DE MOEDA
    // ============================================
    
    public bool AddCurrency(int amount)
    {
        if (amount <= 0) return false;
        
        int newAmount = Mathf.Min(currentCurrency + amount, maxCurrency);
        int added = newAmount - currentCurrency;
        
        if (added > 0)
        {
            currentCurrency = newAmount;
            OnCurrencyChanged?.Invoke();
            SaveToGameData();
            return true;
        }
        
        return false;
    }
    
    public bool RemoveCurrency(int amount)
    {
        if (amount <= 0) return false;
        
        if (currentCurrency >= amount)
        {
            currentCurrency -= amount;
            OnCurrencyChanged?.Invoke();
            SaveToGameData();
            return true;
        }
        
        return false;
    }
    
    public bool HasCurrency(int amount)
    {
        return currentCurrency >= amount;
    }
    
    // ============================================
    // USO DE ITENS
    // ============================================
    
    public bool UseItem(ItemData item, BattleUnit target = null)
    {
        if (item == null || !item.IsConsumable()) return false;
        if (!HasItem(item, 1)) return false;
        
        bool usedSuccessfully = ApplyItemEffects(item, target);
        
        if (usedSuccessfully)
        {
            RemoveItem(item, 1);
            SaveToGameData();
        }
        
        return usedSuccessfully;
    }
    
    private bool ApplyItemEffects(ItemData item, BattleUnit target)
    {
        bool appliedEffect = false;
        
        if (item.hpRestore > 0 && target != null)
        {
            target.Heal(item.hpRestore);
            appliedEffect = true;
        }
        
        return appliedEffect;
    }
    
    // ============================================
    // MÃ‰TODOS DE UTILIDADE
    // ============================================
    
    public List<InventorySlot> GetAllSlots()
    {
        return new List<InventorySlot>(inventorySlots);
    }
    
    public List<InventorySlot> GetNonEmptySlots()
    {
        return inventorySlots.Where(slot => !slot.IsEmpty).ToList();
    }
    
    public int GetEmptySlotCount()
    {
        return inventorySlots.Count(slot => slot.IsEmpty);
    }
    
    public int GetUsedSlotCount()
    {
        return inventorySlots.Count(slot => !slot.IsEmpty);
    }
    
    public bool IsInventoryFull()
    {
        return GetEmptySlotCount() == 0;
    }
    
    // ============================================
    // DEBUG
    // ============================================
    
    [ContextMenu("Debug: Print Inventory")]
    public void DebugPrintInventory()
    {
        Debug.Log("=== INVENTORY DEBUG ===");
        Debug.Log($"Currency: {currentCurrency}");
        Debug.Log($"Slots: {GetUsedSlotCount()}/{inventorySize}");
        Debug.Log($"Weight: {currentWeight:F1}/{maxWeight:F1} kg");
        
        int itemCount = 0;
        foreach (var slot in inventorySlots)
        {
            if (!slot.IsEmpty)
            {
                itemCount++;
                Debug.Log($"Slot {slot.slotIndex}: {slot.quantity}x {slot.item.itemName}");
            }
        }
        
        if (itemCount == 0)
        {
            Debug.Log("Inventory is empty");
        }
    }
    
    [ContextMenu("Debug: Clear Inventory")]
    public void DebugClearInventory()
    {
        inventorySlots.Clear();
        InitializeInventory();
        currentCurrency = 0;
        
        OnInventoryChanged?.Invoke();
        OnCurrencyChanged?.Invoke();
    }

    // ADICIONE ESTE MÃ‰TODO NO InventoryManager.cs

    [ContextMenu("ğŸ” Debug: Print Equipment Loadout")]
    public void DebugPrintEquipmentLoadout()
    {
        Debug.Log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Debug.Log("â•‘  ğŸ¯ EQUIPMENT LOADOUT DIAGNOSIS           â•‘");
        Debug.Log("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        
        if (currentEquipment == null)
        {
            Debug.LogError("âŒ currentEquipment is NULL!");
            Debug.Log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            return;
        }
        
        var slotTypes = System.Enum.GetValues(typeof(ItemData.EquipmentSlot));
        
        foreach (ItemData.EquipmentSlot slot in slotTypes)
        {
            if (slot == ItemData.EquipmentSlot.None) continue;
            
            var item = currentEquipment.GetItemInSlot(slot);
            
            if (item != null)
            {
                Debug.Log($"â•‘  âœ… [{slot}]: {item.itemName}");
            }
            else
            {
                Debug.Log($"â•‘  â¬œ [{slot}]: Empty");
            }
        }
        
        Debug.Log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }

    
    // ============================================
    // PROPRIEDADES PÃšBLICAS
    // ============================================
    
    public int Currency => currentCurrency;
    public int MaxCurrency => maxCurrency;
    public int InventorySize => inventorySize;
    public EquipmentLoadout Equipment => currentEquipment;
    public float CurrentWeight => currentWeight;
    public float MaxWeight => maxWeight;
    public bool CanCarryWeight(float additionalWeight) => currentWeight + additionalWeight <= maxWeight;
}

